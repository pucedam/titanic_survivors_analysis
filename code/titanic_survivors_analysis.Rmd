---
title: "Análisis de los supervivientes del Titanic."
author: 
- "Pedro Uceda Martínez"
- "Pablo Campillo Sánchez"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
abstract: |
  Mediante este documento se desarrolla la __Práctica 2: Limpieza y análisis de datos__ de la asignatura de __Tipología y Ciclo de Vida de los Datos__ del __Máster Universitario en Ciencia de Datos__ de la __Universidad Oberta de Catalunya__.

Práctica 2: Limpieza y análisis de datos. 

output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

packages <- c("ggplot2", "dplyr", "pROC", "tidyr", "usedist", "cluster", "factoextra", "NbClust")
install.packages(setdiff(packages, rownames(installed.packages()))) 

library(ggplot2)
library(plyr)
library(dplyr)
library(gridExtra)
library(pROC)
library(tidyr)
library(usedist)
library(cluster)
library(fpc)
library(factoextra)
library(NbClust)
require(knitr)

```

\newpage

# 1. Descripción del dataset

Durante esta práctica vamos a tratar el _dataset_ base de la competición [**Titanic - Machine Learning from Disaster**](https://www.kaggle.com/c/titanic/overview). En este conjunto de datos se nos presenta, para cada pasajero del tan famoso trasatlántico, sus datos personales más importantes, así como otros relacionados con su embarque en el Titanic, y si finalmente sobrevivieron al naufragio del mismo.

De este modo, este estudio es interesante dado que nos permite analizar cuáles fueron los factores que afectaron a la supervivencia de los pasajeros. Así, podremos, entre otras cosas, ver si solamente la clase del billete, el género y la edad condicionaron que un viajero se salvase tal y como hemos visto en la gran pantalla o bien hubiera habido otros factores que pudieran haber determinado la supervivencia del pasajero, como el número de billete.

Las variables de las que disponemos, para cada pasajero, son:

- **PassengerId**: Identificador artifical del pasajero.
- **Survived**: Si sobrevivió (1) o no (0).
- **Pclass**: Clase del pasaje. 
- **Name**: Nombre del pasajero.
- **Sex**: Sexo del viajero.
- **Age**: Edad, en años.
- **SibSp**: Número de hermanos o esposas a bordo del Titanic.
- **Parch**: Número de padres / hijos a bordo del Titanic.
- **Ticket**: Número de ticket.
- **Fare**: Tarifa del pasaje.
- **Cabin**: Número de camarote.
- **Embarked**: Puerto desde el que embarcó el pasajero. Las posibles opciones son: Cherbourg (C), Queenstown (Q) o Southampton (S).

\newpage

# 2. Integración y selección de los datos de interés a analizar.

Los datos a procesar provienen de __una única fuente__, por ello, __no es necesario realizar la fase de integración__ o
fusionado de los datos. En este apartado, primero __se cargarán los datos y se hará una exploración inicial__ de los mismos para
tener una idea más clara de como se distribuyen y, posteriormente, se procederá a __seleccionar los datos de interés__ y a __generar nuevas
características__ que puedan resultar interesantes para el análisis posterior.

## 2.1 Exploración de los datos (screening)

A continuación, cargamos el __dataset__, sin __factors__, para evitar tratar los nombres de los pasajeros como tales.

```{r echo=TRUE, message=FALSE, warning=FALSE}
ds <- read.csv(file = "../data/titanic_survivors.csv", header=TRUE, stringsAsFactors=FALSE)
str(ds)
```

Como se puede observar, el ___dataset___ contiene __891 registros y 12 atributos__. Están presentes las __variables cuantitativas PassengerId, Survived, Pclass, Age, SibSp, Parch y Fare__, todas tratadas como __int o num__. También tenemos las __variables cualitativas Ticket, PClass, Sex y  Cabin, cargadas como cadena de caracteres__. __Survived__, aun siendo variable cuantitativa, representa 0 (No) y 1 (Yes), por lo que __en realidad es una variable cualitativa dicotómica__. 

Para más claridad de los datos, procedemos a realizar las __siguientes transformaciones__:

- Transformamos el campo __Survived__ a uno __categórico__ con __dos valores, "Yes" y "Not"__, representando si el pasajero sobrevivió o no, respectivamente.
- Transformamos el campo cualitativo categórico __Embarked a un factor con 3 posibles valores__, cada uno con el nombre del puerto.
- Transformamos el __campo dicotómico Sex a un factor con 2 niveles, en lugar de trabajarlo como cadena de texto__.
- Transformamos el __campo Pclass__, que se ha cargado como campo cuantitativo, __a un factor con tres niveles, ordenado,__ y le asignamos las etiquetas "1st", "2nd", "3rd".

```{r echo=TRUE, message=FALSE, warning=FALSE}

#Transformamos Survived a factor
ds$Survived <- factor(ds$Survived, levels=c(0, 1), labels = c("Not", "Yes"))

#Convertimos Embarked a factor con 3 niveles
embarked_labels <- c("Cherbourg", "Queenstown", "Southampton")
ds$Embarked <- factor(ds$Embarked, levels=sort(c("C", "Q", "S")), labels = embarked_labels)

#Convertimos Sex a factor con 2 niveles, female | male
ds$Sex <- factor(ds$Sex)

#Convertimos Pclass a un factor ordenado
ds$Pclass <- factor(ds$Pclass, ordered=TRUE, levels=c(1, 2, 3), labels=c("1st", "2nd", "3rd"))

#Revisamos como quedan los datos en el dataset
str(ds)

```

Para hacernos una idea de las características más importantes de los atributos, vamos a mostrar las estadístcas básicas:

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(ds)
```

La información más relevante es:

- **Survived**: Hay más gente que falleció que sobrevivió.
- **Pclass**: Lo más común es viajeros con billetes de tercera clase.
- **Sex**: En el barco viajaban el doble de hombres que de mujeres.
- **Age**: Especifica la edad en años. Podemos ver que el mínimo es 0.42 años, así que se contemplan bebés. La persona más anciana tenía 80 años y la media de edad estaba en torno a los 30 años. La mitad de los viajeros tenía 28 años o menos.
- **SibSp**: Lo más común es ir sin hermanos ni mujer, es decir, viajar solo.
- **Parch**: Es menos común todavía ir con descendientes o ascendientes.
- **Fare**: La media del precio del billete es 32.2 y la mediana 14. Esto indica que hay mucha disparidad de precios, siendo el máximo 512.
- **Embarked**: La mayoría embarcaron de Southamption, luego de Cherbourg y unos pocos de Queenstown.

Por último, hacemos una inspección visual de los campos que menos sabemos sobre ellos: Ticket y Cabin.

### 2.1.1 Campo Ticket

La codificación del billete (Ticket) parece que sigue diferentes patrones y además, __hay viajeros que comparten
ticket__ ya que si los ordenamos, podemos comprobar que estos se repiten:

```{r echo=TRUE, message=FALSE, warning=FALSE}
#Mostramos los 10 primeros tickets según orden
sort(ds$Ticket)[1:10]
```

Si comprobamos los campos únicos, vemos que pasa de 891 a 681 valores diferentes, lo que indica que __hay valores de ticket repetidos__:

```{r echo=TRUE, message=FALSE, warning=FALSE}
length(distinct(ds, Ticket)$Ticket)
```

Además, el que un ticket se repita no depende de su tipo:
```{r echo=TRUE, message=FALSE, warning=FALSE}
aux <- count(ds, Ticket)
aux[order(aux[,2], decreasing = TRUE), ][1:10, ]
```

Suponemos que se puede comprar un mismo billete para varias personas. ¿Compartirán el camarote? ¿Serán familia?
Veamos los datos de estos 8.

**Ticket 1601**: Varias personas de origen chino tienen un billete común y, según los datos, no tienen parentesco entre sí.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "1601", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket 347082:** Familia formada por 2 padres y 5 hijos de 2, 4, 6 y 9 años.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "347082", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket CA. 2343:** Deben ser hermanos viajando con sus esposas ya que tienen todas el mismo apellido y, aunque no se sabe la edad, el billete es caro (saldrían a 10 libras por cabeza)

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "CA. 2343", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket 347088:** Matrimonio con sus 4 hijos de 2, 4, 9 y 10 años.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "347088", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket 3101295:** Madre con sus 5 hijos de 1, 2, 7, 14 y 16 años.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "3101295", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket 347088:** Matrimonio con sus 4 hijos de 2, 4, 9 y 10 años.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "347088", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket CA 2144:** Madre con sus 5 hijos de 1, 9, 11, 14 y 16 años.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "CA 2144", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket 382652:** Madre con sus 4 hijos de 2, 4, 7 y 8 años.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "382652", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

**Ticket S.O.C. 14879:** Billete de 2a clase compartido entre hermanos e, imaginamos, que amigos.

```{r echo=TRUE, message=FALSE, warning=FALSE}
select(ds[ds$Ticket == "S.O.C. 14879", ], Name, Pclass, Fare, Cabin, Embarked, Sex, Age, SibSp, Parch)
```

La exploración del campo Ticket nos revela que __los billetes se comparten__, este hecho se ha confirmado tras estudiar un poco de historia en Wikipedia (https://en.wikipedia.org/wiki/Passengers_of_the_Titanic). Resulta que __el precio típico de los billetes del Titanic era de 7, 13 y desde 30 libras tercera, segunda y primera clase, respectivamente__. El precio de los niños de tercera era 3 libras. Por tanto, al menos, para hacer un análisis por persona, habría que:

- Adaptar el __precio por persona__: dividiendo fare por el número de personas que disponen del billete.
- Un campo nuevo podría indicar con __cuántas personas se compartía el billete__.
- Si del nombre nos quedamos con el apellido, podemos analizar también la __probabilidad de muerte en función del apellido__. ¿Hay apellidos más afortunados que otros o de clases sociales diferentes?

Por otro lado, al nombre del Ticket no hemos conseguido sacar una relación o significado claro a primera vista.

### 2.1.1 Campo Cabin

Al igual que con el campo Ticket, se han agrupado y contado los valores del campo Cabin. Como se puede ver en la tabla de abajo, __la gran cantidad de registros no contiene el nombre del camarote (687)__. Los nombres de los camarotes parece que están __formados__ por la __letra de la cubierta (A-F) y seguido de un número__. La mayoría de los registros corresponden a 1a clase, aunque también hay registros con 2a y 3a. También llama la atención, que recoge más de un camarote.

```{r echo=TRUE, message=FALSE, warning=FALSE}
aux <- count(ds, Cabin)
head(aux[order(aux[,2], decreasing = TRUE), ])
```

## 2.2 Selección y creación de características

Como hemos visto en el apartado anterior, tras explorar el campo Ticket, vimos que podíamos __crear nuevos campos__:

- **Surname**: Campo del apellido del propietario del billete.
- **TicketOwners**: Número de propietarios de un billete.
- **PricePerPerson**: Precio del billete por persona, ya que Fare contiene el precio del billete total.

Los nombres están formados primero por el apellido, luego una coma y después el nombre. __Para extraer el apellido, simplemente separamos por coma y nos quedamos con la primera parte__:

```{r echo=TRUE, message=FALSE, warning=FALSE}

ds <- separate(ds, Name, c("Surname", NA))

head(ds)
```

Luego, obtenemos el __número de propietarios por billete__ (TicketOwners) y con este campo __obtenemos el precio por persona__ (PricePerPerson). Los campos nuevos generados serían:

```{r echo=TRUE, message=FALSE, warning=FALSE}
aux <- count(ds, Ticket)
ds <- merge(x = ds, y = aux, by = "Ticket", all.x = TRUE)
colnames(ds)[13] <- "TicketOwners"
ds$PricePerPerson <- ds$Fare / ds$TicketOwners
head(select(ds, Surname, TicketOwners, PricePerPerson))
```

__Los atributos PassengerId, Ticket, Fare y Name no serán objeto de análisis__. Por tanto, los campos que finalmente se consideran para ser limipados y analizados son:

```{r echo=TRUE, message=FALSE, warning=FALSE}
ds <- subset(ds, select = -c(PassengerId, Ticket, Fare) )
str(ds)
```

A continuación,  __salvamos los datos con estas nuevas carácterísticas__ que hemos extraído en un nuevo fichero, que llamaremos __data/titanic_survivors_with_characteristics.csv__:

```{r}

write.csv(ds,"../data/titanic_survivors_with_characteristics.csv", row.names = TRUE)

```

\newpage

# 3. Limpieza de datos

En este apartado vamos a limpiar los datos para que el análisis posterior y los modelos generados sean más representativos y correctos.


## 3.1  Elementos vacíos

Primero, vamos comprobar aquellos campos que son nulos o vacíos:

```{r echo=TRUE, message=FALSE, warning=FALSE}
#Estadísticas básicas
summary(ds)

# Estadísticas de valores vacíos
colSums(is.na(ds))
colSums(ds=="")
```

Vemos que los campos que tienen campos nulos o vacíos son:

- **Age** tiene __177 valores nulos__ y su valor debe ser mayor de cero. En este caso, lo ideal sería generar un modelo de regresión que predijese la edad ya que puede depender de la clase, el sexo pero sobre todo de la clase y el precio, ya que los niños pagan menos. Por simplicidad, ___vamos __imputamos a estos valores nulos la mediana de las edades__.
- **Embarked** tiene __2 valores nulos__ y cada persona tiene que haber embarcado desde algún puerto. En este caso, con el ticket a lo mejor se podría deducir desde donde se ha embarcado. En este caso, __asignaremos el puerto más probable__, es decir, __desde donde más gente embarcó__.
- **Cabin** tiene __687 valores vacíos y cada persona tiene que dormir en algún camarote__. La cantidad de nulos es enorme, sobre todo para los de tercera clase. El camarote exacto no se puede averiguar. En base a la clase, se podría asignar una letra de cubierta. Pero para ello habría que cambiar la variable Cabin por Desk. En este caso, lo que haremos será __eliminar la variable__.  

Como podemos comprobar, ya no hay nulos:

```{r echo=TRUE, message=FALSE, warning=FALSE}
#Imputamos la mediana a los valores nulos de Age
age_median <- median(ds$Age, na.rm = TRUE)
ds[, 'Age'][is.na(ds[,'Age'])] <- age_median

#Imputamos el puerto de embarque más frecuente al campo Embarked
embarked_most_frequent <-  levels(ds$Embarked)[which.max(ds$Embarked)]
ds[, 'Embarked'][is.na(ds[,'Embarked'])] <- embarked_most_frequent

#Eliminamos el atributo Cabin
ds <- subset(ds, select = -c(Cabin) )

summary(ds)
```


## 3.2 Identificación y tratamiento de valores extremos.

En este apartado vamos a __analizar los valores de los campos numéricos para ver si hay valores que no tienen sentido o resultan extraños__, por ejemplo, los __valores extremos__ o ___outliers___. Un criterio para identificar los valores extremos son __aquellos que se sitúan a 3 veces la desviación estándar de la media o más__. Una herramienta muy útil para identificar dichos valores son las __gráficas de caja__. Veamos por variables:

**Age**: Si hacemos las gráficas por clase, podemos ver que hay __valores extremos pero están dentro de un rango de edades
normal, entre 0.42 y 80__. Se puede comprobar cómo, __cuanto mejor es la clase, mayor es la edad__.

```{r echo=TRUE, message=FALSE, warning=FALSE}
gAge1 <- ggplot(ds, aes(x=Pclass, y=Age)) + geom_boxplot()
gAge1
```

**SibSp** y **Parch**: En ambos casos se presentan ___outliers___ porque __lo más común es viajar sin familiares y hay casos de 3, 4, 5 y hasta 8 hermanos, lo cual no es extraño en aquella época__. Así que __los valores__ para estos campos __se consideran correctos__.

```{r echo=TRUE, message=FALSE, warning=FALSE}
gSibSp <- ggplot(ds, aes(x=Pclass, y=SibSp)) + geom_boxplot()
gParch <- ggplot(ds, aes(x=Pclass, y=Parch)) + geom_boxplot()
grid.arrange(gSibSp,gParch,nrow=1)
```

**TicketOwners** y **PricePerPerson**: Para __la tercera y segunda clase, lo más común es viajar sólo__ y __en primera__ es viajar __con un acompañante__. El __número de personas máximo que comparten billete es 8__ pero es normal si se considera que había alguna familiar con hasta 8 hermanos. Los datos son consistentes. Si vemos __los precios__ por clase, vemos cómo son cada vez __más elevados en función de la clase__. Vemos __outliers para tercera y segunda__, por ejemplo, no es correcto que billetes de tercera clase cuestan 20 libras. En cambio, para primera clase, no es raro que haya outliers, ya que el lujo nunca tiene techo. Según las investigaciones, hubo pasajeros de primera clase que llegaron a pagar más de 1000 libras.

```{r echo=TRUE, message=FALSE, warning=FALSE}
gTicketOwners <- ggplot(ds, aes(x=Pclass, y=TicketOwners)) + geom_boxplot()
gPricePerPerson <- ggplot(ds, aes(x=Pclass, y=PricePerPerson)) + geom_boxplot()
grid.arrange(gTicketOwners,gPricePerPerson,nrow=1)
```
En este caso, lo que vamos a tratar, son __aquellos casos en el que el precio del billete por persona es cero__, ya que eso __no puede darse__ a menos que la persona sea de la tripulación pero suponemos que son __todos pasajeros__. Por tanto, lo que haremos será __reemplazar todos los valores 0 del campo PricePerPerson, por la mediana__ de dicho precio en función de a la clase que pertenezca el pasajero. Nótese que esta casuística no se localizó en el apartado anterior, que trataba de valores nulos, debido a que el campo vale cero y no NA en este caso.

```{r echo=TRUE, message=FALSE, warning=FALSE}
price_per_class <- aggregate(ds$PricePerPerson,         # Median by group
          list(ds$Pclass),
          median)
colnames(price_per_class) <- c("Pclass", "PricePerPerson")

#Mostramos la mediana por clases
price_per_class
```

```{r echo=TRUE, message=FALSE, warning=FALSE}

#Sustituimos los valores con las medianas
ds[ds$PricePerPerson == 0 & ds$Pclass == "1st", ]$PricePerPerson <- price_per_class[1, 2]
ds[ds$PricePerPerson == 0 & ds$Pclass == "2nd", ]$PricePerPerson <- price_per_class[2, 2]
ds[ds$PricePerPerson == 0 & ds$Pclass == "3rd", ]$PricePerPerson <- price_per_class[3, 2]
```

Con los datos limpios, procedemos a su guardado en el fichero __titanic_passangers_processed.csv__ y a realizar el análisis en el siguiente apartado.
 
```{r}

write.csv(ds,"../data/titanic_survivors_processed.csv", row.names = TRUE)

```

\newpage

# 4. Análisis de los datos

De manera previa a analizar los datos, __analizamos de manera visual la normalidad__ de los mismos, para tener una idea más clara si cabe de cómo se distribuyen los distintos atributos. Asimismo, mostraremos, para cada atributo, el histograma.

```{r}
par(mfrow=c(2,2))
for(i in 1:ncol(ds)) {
  if (is.numeric(ds[,i])){
    qqnorm(ds[,i],main = paste("Gráfico Q-Q de normalidad ",colnames(ds)[i]))
    qqline(ds[,i],col="red")
    hist(ds[,i], 
      main=paste("Histograma de ", colnames(ds)[i]), 
      xlab=colnames(ds)[i], freq = FALSE)
  }
}


```

De estos gráficos extraemos que:

- La variable __Age__ presenta una distribución más o menos simétrica, unimodal con pico en 28 años (mediana). Podría ser normal.

- El __resto de atributos no presenta una distribución normal__. 

- Como hemos mencionado en apartados anteriores, __lo más común era viajar solo__. Asimismo, el precio por persona -PricePerPerson- presenta una distribución asimétrica con cola a la derecha. 


Además, dibujamos estos campos cuantitativos para __ver si podemos establecer alguna correlación entre ellos__ a simple vista:
```{r}
plot(ds[,c("Pclass", "Sex", "Age", "SibSp", "Parch", "Embarked")])
```
Vemos que aparentemente no hay relaciones lineales entre estos atributos.


Visualizamos también __las variables cuantitativas__:

```{r}

#Visualizacion de variables cuantitativas

#PClass and Survived
sumPClass <- summarize( group_by(ds, Pclass), n=length(Pclass), Survived=mean(Survived))
gPClass1 <- ggplot( sumPClass, aes(x="", y=n, fill=Pclass)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) + ggtitle("PClass")
gPClass2 <- ds %>%
  group_by(Survived, Pclass) %>%
  tally() %>%
  group_by(Survived) %>%
  mutate(x = n / sum(n)) %>%
  ggplot() +
    geom_col(aes(
      x = factor(Pclass),
      y = x,
      fill = factor(Survived)
      ), position = "stack")

#Sex and Survived
sumSex <- summarize( group_by(ds, Sex), n=length(Sex), Survived=mean(Survived))
gSex1 <- ggplot( sumSex, aes(x="", y=n, fill=Sex)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) + ggtitle("Sex")
gSex2 <- ds %>%
  group_by(Survived, Sex) %>%
  tally() %>%
  group_by(Survived) %>%
  mutate(x = n / sum(n)) %>%
  ggplot() +
    geom_col(aes(
      x = factor(Survived),
      y = x,
      fill = factor(Sex)
      ), position = "stack")
#Embarked and Survived
sumEmbarked <- summarize( group_by(ds, Embarked), n=length(Embarked))
gEmbarked1 <- ggplot( sumEmbarked, aes(x="", y=n, fill=Embarked)) +
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) + ggtitle("Embarked")
gEmbarked2 <- ds %>%
  group_by(Survived, Embarked) %>%
  tally() %>%
  group_by(Survived) %>%
  mutate(x = n / sum(n)) %>%
  ggplot() +
    geom_col(aes(
      x = factor(Embarked),
      y = x,
      fill = factor(Survived)
      ), position = "stack")

grid.arrange(gPClass1,gPClass2, gSex1, gSex2, gEmbarked1, gEmbarked2, ncol=2)

```

Podemos observar que __los pasajeros de primera y segunda clase sobrevivieron mucho más que los de tercera__. Asimismo, __una gran proporción de las mujeres se salvó, frente a la pequeña parte de los varones__. Además, aparentemente __los embarcados en Cherbourg sobrevivieron más__ que los embarcados en los otros dos puertos.

## 4.1 Selección de los grupos de datos que se quieren analizar / comparar.

A continuación, se nombran los distintos grupos de datos que nos parecen interesantes:

- Analizaremos si __los niños__, entendiendo como tales los pasajeros que tenían 16 años o menos, __tuvieron la misma probabilidad de sobrevivir que los adultos o, por el contrario, más__. Compararemos los dos subgrupos de viajeros para responder a la siguientes hipótesis, teniendo __Ps(X) como la probabilidad de supervivencia del subgrupo X__:

$$
  H_{0} : p_s(children) = p_s(adults)
$$
$$
  H_{1} : p_s(children) > p_s(adults)
$$


- Intentaremos __aproximar los datos__ utilizando __un modelo de regresión__. __Partiremos de la edad__, con la que habremos trabajado anteriormente, __y el sexo__, y veremos si podemos incluir una tercera variable que nos permita que mejore el comportamiento de nuestro modelo

- Haremos un __análisis de correlación__ de los datos con la variable objetivo. ¿Cuanto más cuesta el billete hay más probabilidades de sobrevivir?

- Por último, realizaremos un __modelo no supervisado jerárquico__ para ver cómo afectan cada variable a la supervivencia de los pasajeros.


A continuación, creamos un dataset para los pasajeros que son niños y otro para los adultos. Utilizaremos tales dataset posteriormente para realizar el contraste de hipótesis del primer caso.

```{r}

children_passengers <- ds[ds$Age <= 16,] 
adults_passengers <- ds[ds$Age > 16,] 

```

## 4.2. Comprobación de la normalidad y homogeneidad de la varianza

Comprobamos si el atributo Age de los pasajeros, objeto de nuestro análisis, sigue una distribución normal, utilizando el test de Shapiro-Wilk:

```{r}

shapiro.test(ds$Age)

```

Obtenemos un __p-palor muy pequeño, menor al nivel de significancia 0.05__, por lo que podemos rechazar la hipótesis nula del __test__ y asumimos que __la variable Age no sigue una distribución normal__. No obstante, al tener un número de registros lo suficientemente grande (n > 30), en virtud del __Teorema del Límite Central__ podemos considerar que los __datos sí se distribuirán siguiendo una distribución normal__.

Dado que la variable Age no sigue una distirbución normal, utilizaremos el __test de Fligner-Killeen__ para comprobar la homocedasticidad de la variable:

```{r}
fligner.test(Age~Survived, data = ds)

```
Observamos que dado el p-value obtenido, menor que 0.05, no podemos rechazar la hipótesis nula y concluimos que __la variable Age presenta una distribución homogénea de la varianza__.

Asimismo comprobamos si ambos subgrupos que vamos a comparar tienen la misma varianza:
```{r}

var.test(children_passengers$Age, adults_passengers$Age)

```

Por el p-value obtenido, muy pequeño, y el ratio que nos devuelve el test concluimos que __la varianza no es la misma para los dos grupos de supervivientes__ (niños y adultos).

# 4.3. Aplicación de pruebas estadísticas para comparar los grupos de datos

## 4.3.1 Supervivencia de niños vs adultos

Aunque la variable Age presente una distribución de la varianza homogénea, no tiene una distribución normal, por lo que no podemos utilizar tests pamétricos para comparar ambos grupos de datos. Utilizaremos pues el __test de Wilcox, no paramétrico, para comprobar si los niños sobrevivieron  más que los adultos__. Nótese que suponiendo la normalidad de los datos gracias al TLC, podríamos haber utilizado una t-student (función t.test en R) para realizar el contraste de hipótesis.

```{r}
  
  wilcox.test(children_passengers$Age, adults_passengers$Age, alternative = "greater")

```

Como vemos por el p-value con valor 1, el test nos arroja de manera decisiva que __los niños__ (primer grupo) __sobrevivieron mucho más que los adultos__ (segundo grupo).

A modo de comprobación, comprobamos que mediante la utilización del test obtenemos que para la hipotesis nula contraria:

```{r}
  
  wilcox.test(children_passengers$Age, adults_passengers$Age, alternative = "less")


```

En este caso el test nos arroja un valor p muy pequeño, lo que nos permite rechazar la hipotesis nula, si la hiciesemos, de que los niños sobrevivieron significiamente menos que los adultos.


## 4.3.2 Modelo de regresión

Como hemos comentado en el apartado 4.1, comenzaremos a construir nuestro modelo de regresion con los atributos Age y Sex. Dado que la variable __Survived es una variable cualitativa categórica__, utilizamos un __modelo de regresión logística__ en detrimento del lineal, ya que el rendimiento del primero es mejor en este caso.

Procedemos construir este primer modelo y ver cómo se comporta:

```{r}

# Modelo logistico con Survived explicado por Age y Sex
model.logist1 = glm(formula = Survived ~ Age + Sex, family=binomial(link=logit), data = ds)

summary(model.logist1)


```

Vemos por el estadístico de Wald que la variable __Sex (p-value<0.05) sí es estadísticamente significativa, pero Age (p-value>0.05) no__. Por lo tanto, procedemos a __quitar la variable Age del modelo__.

Del ___data screaning___ observamos que el __Pclass parecía tener relación con la supervivencia__, puesto que los pasajeros de primera y segunda clase sobrevivieron mucho más que los de tercera. Procedemos a __incluirlo en el modelo en detrimento del atributo Age__ y vemos también el rendimiento del nuevo modelo:

```{r}
# Modelo logistico con Survived explicado por Sex y Pclass

model.logist2.formula = Survived ~ Sex + Pclass

model.logist2 = glm(formula = model.logist2.formula, family=binomial(link=logit), data = ds)

summary(model.logist2)

```

Podemos observar que la variable __Pclass es estadísticamente significativa__ y vemos que __el modelo mejora, ya que el Akaike Information Criterion (AIC) es menor que en el primer modelo__ que realizamos.

Probamos a incluir también __la variable SibSp en el modelo__, ya que de manera intutiva tiene sentido que los hombres que viajasen solos sobreviviesen más que los que viajasen con esposa.

```{r}

# Modelo logistico con Survived explicado por Sex, Pclass y SibSp 

model.logist3.formula = Survived ~ Sex + Pclass + SibSp

model.logist3 = glm(formula = model.logist3.formula, family=binomial(link=logit), data = ds)

summary(model.logist3)


```

Vemos que __SibSp también es estadísticamente significativa y que mejora un poco el rendimiento del algoritmo__.

Probamos a __incorporar del mismo modo la variable Parch__:

```{r}
# Modelo logistico con Survived explicado por Sex, Pclass, SibSp y Parch

model.logist4 = glm(formula = Survived ~ Sex + Pclass + SibSp + Parch, family=binomial(link=logit), data = ds)

summary(model.logist4)


```

Vemos que __la variable Parch no es estadísticamente significativa__, ya que su estadístico de Wald es mayor que 0.05, por lo que __la descartamos__. Comprobamos por último si el precio que pagó cada pasajero por el ticket mejoraría el modelo:

```{r}

# Modelo logistico con Survived explicado por Sex, Pclass, SibSp y PricePerPerson

model.logist5 = glm(formula = Survived ~ Sex + Pclass + SibSp + PricePerPerson, family=binomial(link=logit), data = ds)

summary(model.logist5)


```

Podemos observar que __la variable PricePerPerson tampoco es estadísticamente significativa, por lo que también la eliminamos del modelo__.


Tras este proceso, podemos concluir que __el  modelo logístico que mejor explica la variable Survived es nuestro tercer modelo__, que utiliza Age , Pclass y SibSp para explicar la variable Survived:

$$
  Survived = exp(3.43 -2.74*Sexmale -0.93*Pclass - 0.24*SibSp)
$$

## 4.3.3 Análisis del modelo no supervisado

En este apartado vamos a ver cómo métodos de agregación agrupa los pasajeros en función de sus características. Para ello, es importante que la función de distancia esté bien definida y los valores estén en el mismo rango para que no haya sesgos. Posteriormente, habrá que averiguar cuál es el número de clusters óptimo, en principio, debería ser el número de valores de la variable objetivo (en este caso 2). Y finalmente analizar qué propiedades tiene cada cluster.

Las variables disponibles son:

```{r echo=TRUE, message=FALSE, warning=FALSE}
colnames(ds)
```
Pero vamos a centrarnos en __las propiedades más importantes: "Sex", "Age", "Pclass" y "Survived"__.

Primero calculamos la __matriz de distancia__ normalizando con minMax y haciendo distancia de Mahalanobis.

```{r echo=TRUE, message=FALSE, warning=FALSE}

maxAge <- max(ds$Age)
minAge <- min(ds$Age)

distance <- function (v1, v2) (as.integer(v1$Survived != v2$Survived) + as.integer(v1$Sex != v2$Sex) + abs(as.integer(v1$Pclass) - as.integer(v2$Pclass)) / 2 + ((v1$Age - v2$Age) / (maxAge - minAge))) / 4

distance_matrix <- dist_make(ds, distance)
```

Ahora vamos a utilizar la matriz de distancia para __generar las agrupaciones__. El método que se va a emplear es el __k-medoids__ ya que no tiene sentido hacer medias con registros categóricos y, por ello, se ha dado una matriz de distancias a medida. Hemos utilizado la función fviz_nbclust que imprime el utilizando varios métodos cómo evoluciona una métrica conforme se va ampliando el número de clusters. La __técnica del codo consiste en seleccionar aquel cluster en el que la ganancia de información se estabiliza__. Hemos empleado __dos métodos__:

- __silhouette__ que directamente da el número k de agrupaciones óptimo, en este caso 9.
- __wss__ que no lo da, pero que coincide a simple vista con el anterior.


```{r echo=TRUE, message=FALSE, warning=FALSE}

fviz_nbclust(as.matrix(distance_matrix), pam, method = "silhouette") +
  labs(subtitle = "Elbow method")
```

```{r echo=TRUE, message=FALSE, warning=FALSE}

fviz_nbclust(as.matrix(distance_matrix), pam, method = "wss") +
    geom_vline(xintercept = 2, linetype = 2)+ geom_vline(xintercept = 9, linetype = 2)+
  labs(subtitle = "Elbow method")
```

Si vemos el número de individuos por cada __cluster diferenciando aquellos que sobreviven de los que no__, podemos comprobar que están __perfectamente delimitados__. Sólo hay unos pocos casos para el grupo 1 y el 9:

```{r echo=TRUE, message=FALSE, warning=FALSE}

kmedoids.res1 <- pam(distance_matrix, 9)
table(ds$Survived, kmedoids.res1$cluster)
```
Si analizamos los centroides o __individuos más representatitvos de cada grupo__, obtenemos las siguientes conclusiones:

- Los grupos __supervivientes__ son: __mujeres jóvenes de primera y más mayores de segunda y tercera__, y, aún pareciendo un poco extraño, también se incluyen __hombres mayores de segunda clase__.
- Los grupos que __no sobreviven__ son en __general los hombres de todas las clases__ y __algunas mujeres y niños pequeños de segunda clase__.

\newpage

```{r echo=TRUE, message=FALSE, warning=FALSE}
aux <- ds
aux$Cluster = kmedoids.res1$cluster
aux <- select(aux[kmedoids.res1$medoids, ], Cluster, Sex, Age, Pclass, Survived)
aux[order(aux$Survived), ]
```

# 5. Representación de los resultados a partir de tablas y gráficas

## 5.1 Comparación de la supervivencia de niños y de los adultos

En el apartado anterior, hemos visto que __los niños sobrevivieron mucho más que los adultos__. Podemos __visualizar__ esto de manera gráfica:

```{r}

#Calculamos la media para los dos tipos de pasajeros y lo pintamos en un diagrama de barras

children_passengers$Survived <-as.integer(children_passengers$Survived)
adults_passengers$Survived <- as.integer(adults_passengers$Survived)

mean_children_passengers <- mean(children_passengers$Survived)
mean_adults_passengers <- mean(adults_passengers$Survived)

#Las dibujamos
barplot(c(mean_children_passengers, mean_adults_passengers), names =c("Niños", "Adultos (>16 años)"), main=("Media de supervivencia de los viajeros"), xlab="Edad")
```

Podemos ver también __cómo se distribuye la supervivencia, agrupando los pasajeros por edades__:

```{r echo=TRUE, message=FALSE, warning=FALSE}

#Agrupamos por tramos de edad
ds$AgeGroup <- cut(ds$Age, breaks=c(0,4,8,12,16,20,24,30,40,50,60,70,80))

#Pintamos AgeGroup y Survived
sumAgeGroup <- summarize( group_by(ds, AgeGroup), n=length(AgeGroup))


gAgeGroup1 <- ds %>%
group_by(Survived, AgeGroup) %>%
tally() %>%
group_by(Survived) %>%
mutate(x = n / sum(n)) %>%
ggplot() +
geom_col(aes(
x = factor(AgeGroup),
y = x,
fill = factor(Survived)
), position = "stack")

gAgeGroup1

```

Puede verse que __para los pasajeros con 16 años o menos la supervivencia es significativamente mayor, con la excepción del rango de edad de 4 a 8 años__. Por lo tanto, la supervivencia de los niños es mayor, pero tiene __más dispersión que la de los adultos__.

## 5.2 Modelo de regresión logística

Vemos los coeficientes del modelo que hemos calificado como mejor (el tercero) para ver cómo se comportan las variables que lo explican:

```{r}
exp(coefficients(model.logist3))


##IC 
exp(confint(model.logist3))

```

__La variable Sex tiene un OR de 0.064, la Pclass un OR de 0.39 y la SibSp un 0.78__, por lo que a la hora de explicar la variable Survived sorprendentemente tiene __mucho más peso la variable SibSp que el sexo o la clase__, también debido en parte a que es una variable cuantitativa y su valor puede llegar a 8, si bien tiene un Intervalo de Confianza, con una confianza del 95%, más amplio que las otras dos variables.


Procedemos a ver __cómo se comportaría nuestro modelo de regresión logística a clase y SibSp constantes y distinto sexo__:

```{r}

#Males
new_passengers_male <- data.frame(
  Sex = rep("male", times = 3),
  Pclass = c("1st","2nd","3rd"),
  SibSp = c(1,1,1)
)

#Females
new_passengers_female <- data.frame(
  Sex = rep("female", times = 3),
  Pclass = c("1st","2nd","3rd"),
  SibSp = c(1,1,1)
)

prob_males <- predict(model.logist3, newdata = new_passengers_male, type="response")

prob_females <- predict(model.logist3, newdata = new_passengers_female, type="response")

prob_males

prob_females

plot(c(1,2,3), prob_females, type = "b", frame = FALSE, pch = 19, col = "pink", xlab = "Pclass", ylab = "prob Survived", ylim = c(0,1))

lines(c(1,2,3), prob_males, pch = 19, col = "blue", type = "b")

legend("topright", legend=c(" Mujeres", "Hombres"), col=c("pink", "blue"), lty = c(1,1), cex=0.8)


```

Ahora visualizaremos cómo se comporta con __clase y SibSps constantes y distinto sexo__:

```{r}
new_passengers_class_1 <- data.frame(
  Sex = c("male", "female"),
  Pclass = c("1st","1st"),
  SibSp = c(1,1)
)

new_passengers_class_2 <- data.frame(
  Sex = c("male", "female"),
  Pclass = c("2nd","2nd"),
  SibSp = c(1,1)
)

new_passengers_class_3 <- data.frame(
  Sex = c("male", "female"),
  Pclass = c("3rd","3rd"),
  SibSp = c(1,1)
)

prob_1 <- predict(model.logist3, newdata = new_passengers_class_1, type="response")

prob_2 <- predict(model.logist3, newdata = new_passengers_class_2, type="response")

prob_3 <- predict(model.logist3, newdata = new_passengers_class_3, type="response")

plot(c(1, 2), prob_1, type = "b", frame = FALSE, pch = 19, col = "red", xlab = "Sex", ylab = "prob Survived", ylim = c(0,1))

lines(c(1, 2), prob_2, pch = 19, col = "green", type = "b")

lines(c(1, 2), prob_3, pch = 19, col = "blue", type = "b")

legend("topright", legend=c(" Primera clase", "Segunda clase", "Tercera clase"), col=c("red", "green", "blue"), lty = c(1,1), cex=0.8)


```


Por último, __solamente variaremos el atributo SibSp__. En el caso de los __hombres__:

```{r}
new_passengers_class_1 <- data.frame(
  Sex = rep("male", times = 10),
  Pclass = rep("1st", times = 10),
  SibSp = 1:10
)

new_passengers_class_2 <- data.frame(
  Sex = rep("male", times = 10),
  Pclass = rep(c("2nd"), times = 10),
  SibSp = 1:10
)

new_passengers_class_3 <- data.frame(
  Sex = rep("male", times = 10),
  Pclass = rep("3rd", times = 10),
  SibSp = 1:10
)

prob_1 <- predict(model.logist3, newdata = new_passengers_class_1, type="response")

prob_2 <- predict(model.logist3, newdata = new_passengers_class_2, type="response")

prob_3 <- predict(model.logist3, newdata = new_passengers_class_3, type="response")

plot(c(1:10), prob_1, type = "b", frame = FALSE, pch = 19, col = "red", xlab = "SibSp", ylab = "prob Survived", ylim = c(0,1))

lines(c(1:10), prob_2, pch = 19, col = "green", type = "b")

lines(c(1:10), prob_3, pch = 19, col = "blue", type = "b")

legend("topright", legend=c(" Primera clase", "Segunda clase", "Tercera clase"), col=c("red", "green", "blue"), lty = c(1,1), cex=0.8)

```

Y en el de las __mujeres__:

```{r}
new_passengers_class_1 <- data.frame(
  Sex = rep("female", times = 10),
  Pclass = rep("1st", times = 10),
  SibSp = 1:10
)

new_passengers_class_2 <- data.frame(
  Sex = rep("female", times = 10),
  Pclass = rep("2nd", times = 10),
  SibSp = 1:10
)

new_passengers_class_3 <- data.frame(
  Sex = rep("female", times = 10),
  Pclass = rep("3rd", times = 10),
  SibSp = 1:10
)

prob_1 <- predict(model.logist3, newdata = new_passengers_class_1, type="response")

prob_2 <- predict(model.logist3, newdata = new_passengers_class_2, type="response")

prob_3 <- predict(model.logist3, newdata = new_passengers_class_3, type="response")

plot(c(1:10), prob_1, type = "b", frame = FALSE, pch = 19, col = "red", xlab = "SibSp", ylab = "prob Survived", ylim = c(0,1))

lines(c(1:10), prob_2, pch = 19, col = "green", type = "b")

lines(c(1:10), prob_3, pch = 19, col = "blue", type = "b")

legend("topright", legend=c(" Primera clase", "Segunda clase", "Tercera clase"), col=c("red", "green", "blue"), lty = c(1,1), cex=0.8)

```


Vemos cómo se comporta nuestro modelo: 

```{r}

model=model.logist3

prob=predict(model, ds, type="response")

r=roc(ds$Survived,prob, data=ds)

plot (r)

auc(r)

```

Vemos que el __área bajo la curva es de  0.8328, por lo que la capacidad de predicción de nuestro modelo es bastante buena__. Definimos varias funciones que nos ayudarán a calcular la sensibilidad y la especifidad:

```{r}

calculate_sensibility <- function(confusion_matrix){
  if(ncol(confusion_matrix) != 2) return(0)
  
  yes_yes <- confusion_matrix[2,2]
  yes_no <- confusion_matrix[1,2]
  
  sensibility <- yes_yes / (yes_yes + yes_no)
  
  return(sensibility)
}

calculate_specifity <- function(confusion_matrix){
  if(ncol(confusion_matrix) != 2) return(0)
  
  no_no <- confusion_matrix[1,1]
  no_yes <- confusion_matrix[2,1]
  
  specifity <- no_no / (no_no + no_yes)
  
  return(specifity)
}


calculate_global_accuracy <- function(confusion_matrix){
  if(ncol(confusion_matrix) != 2) return(0)
  
  yes_yes <- confusion_matrix[2,2]
  yes_no <- confusion_matrix[1,2]
  no_no <- confusion_matrix[1,1]
  no_yes <- confusion_matrix[2,1]
  
  ok_results <- yes_yes + no_no
  ko_results <- yes_no + no_yes
  
  ok_results / (ok_results + ko_results)
}


calculate_confusion_matrix <- function(model, data, real_values, threshold){
  predictions <- ifelse(predict(model, newdata = data, type="response")<threshold, "No","Yes")
  
  table(real_values, predictions, dnn = c("Valor Real","Valor Predicho"))
}

```

A continuación, observamos a ver __cómo evoluciona la calidad (sensibilidad, especifidad y calidad total) cambiando el umbral según el cual aceptaremos que nuestro modelo predice si un viajero se salvó o no__:
```{r}

calculate_quality_params <- function(model, data, real_values, threshold){

confusion_matrix <- calculate_confusion_matrix(model, data, real_values, threshold)

specifity <- calculate_specifity(confusion_matrix)

sensibility <- calculate_sensibility(confusion_matrix)

global_accuracy <- calculate_global_accuracy(confusion_matrix)

list("threshold" = threshold, "confusion_matrix" = confusion_matrix, "specifity" = specifity, "sensibility" = sensibility, "global accuracy" = global_accuracy)
}

quality_params_06 <- calculate_quality_params(model.logist3, ds, ds$Survived, 0.6)

quality_params_07 <- calculate_quality_params(model.logist3, ds, ds$Survived, 0.7)

quality_params_08 <- calculate_quality_params(model.logist3, ds, ds$Survived, 0.8)

quality_params_85 <- calculate_quality_params(model.logist3, ds, ds$Survived, 0.85)

quality_params_09 <- calculate_quality_params(model.logist3, ds, ds$Survived, 0.9)

quality_params_06
quality_params_07
quality_params_08
quality_params_85
quality_params_09

```

Vemos que __con un umbral del 0.6, obtenemos una gran sensibilidad (83%) sin comprometer la calidad total (80%)__ por lo que __la calidad de nuestro modelo es bastante aceptable__.

\newpage

# 6. Resolución del problema. A partir de los resultados obtenidos, ¿cuáles son las conclusiones? ¿Los resultados permiten responder al problema?

En primer lugar nos hemos preguntado si los niños sobrevivieron más que los adultos, __comparando el atributo Age entre estas dos subpoblaciones__. Si bien la variable Age no sigue una distribución normal y no podemos explicar el comportamiento de la variable Survived a partir de ella, sí __hemos concluído, con un 95% de confianza, que los niños sobrevivieron mucho más que los adultos__. Asimismo, la supervivencia de los niños está mucho más dispersa que la de los adultos.

Posteriormente, hemos construído un __modelo de regresión lineal logística__ que explica la variable Survived de una manera bastante fidedigna. El modelo es el siguiente:

$$
  Survived = exp(3.43 -2.74*Sexmale -0.93*Pclass - 0.24*SibSp)
$$

__A través del modelo__ mismo y de las gráficas de predicciones del mismo, hemos descubierto que:

- Aunque los niños sobreviviesen mucho más que los adultos, __no podemos establecer un modelo que explique la variable Survived con el atributo Age__.

- En general, __los hombres tienen muchas menos probabilidades de sobrevivir que las mujeres__.

- __La clase también tiene un papel fundamental__. Sin importar si viajaba con su esposa o hermanos, __un hombre de tercera clase _a priori_ tiene muy pocas probabilidades de haber sobrevivido__.

- La variable SibSp, que explica __el número de acompañantes__ de un viajero, __tiene un peso significativo en la supervivencia del pasajero__. __A partir de 6 acompañantes, un hombre, independientemente de su clase, tiene muy pocas probabilidades de sobrevivir__. Podemos observar también cómo __en las mujeres este efecto es menos acusado__, y que una mujer de primera clase, incluso yendo con muchos hermanos, sí tenía mucha más probabilidad de sobrevivir que un hombre.


Por último, también hemos __separado en clusters__ la población de viajeros del Titanic, obteniendo __9 grupos bien diferenciados__ en los que prácticamente todos los componentes sobrevivían o no. Esto nos ha ayudado a __profundizar__ en el conocimiento de __qué tipo de pasajeros sobrevivió o no__, de modo que hemos podido conocer también que las __mujeres que sobrevivían eran especialmente las jóvenes de primera clase y las no tan jóvenes de segunda y tercera además de los hombres mayores de segunda clase__. Asimismo, hemos podido confirmar, una vez más, como ya sabíamos por el modelo, que __por lo general los hombres sobrevivían muchísimo menos__ (aunque no todos murieron) y, __adicionalmente, hemos llegado a conocer que en algunos casos también fallecían mujeres y niños de segunda clase__.



\newpage

# 7. Recursos

- __Calvo M, Subirats L, Pérez D__ (2019). Introducción a la limpieza y análisis de los datos. Editorial UOC.

- __Squire, Megan__ (2015). Clean Data. Packt Publishing Ltd.


# 8. Contribuciones 

```{r}

contributions_table <- tibble::tribble(
                ~Contribuciones,                                         ~Firma,
         "Investigación previa", "Pedro Uceda Martínez, Pablo Campillo Sánchez",
  "Redacción de las respuestas", "Pedro Uceda Martínez, Pablo Campillo Sánchez",
            "Desarrollo código", "Pedro Uceda Martínez, Pablo Campillo Sánchez",
  )

kable(contributions_table, digits = 3, row.names = FALSE, align = "c",
              caption = NULL)

```
